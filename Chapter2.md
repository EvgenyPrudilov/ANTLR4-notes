
--- 2.1 ---

Язык - набор валидных предложений(sentence), которые состоят из фраз(phrase), а те их подфраз(subphrase) и символов(vocabulary symbols). Чтобы реализовать язык, необходимо построить приложение, которое способно читать эти предложения и правильно реагировать на все те вразы и символы, которые обнаружит. Если приложение "выполняет" приложения, то это - интерпретатор(interpreter), если транслирует в другой язык - транслятор(translator); например, компилятор или конвертер(converter)(транспайлер???). Распознать фразу(recognize a phrase) - распознать различные компоненты(его состовляющие) и суметь отличить её от другой фразы.

Программы, которые распознают языки - парсеры(parsers) или синтаксические анализаторы(syntax analyzers). Под синтаксисом(syntax) понимается набор правил, которые определяют пренадлежность к языку. С помощью ANTLR4 грамматики(grammar) мы можем описывать синтаксис языка. Грамматика - набор правил, каждое из которых определяет структуру фразы. ANTLR4 транслирует эту грамматику в парсер. Сама грамматика является мета языком(meta-language), т.к. является языком для описания другого языка.

Токенизация(tokenizing) или лексический анализ(lexical analysis) - процесс группирования символов в слова(words) или символы(symbols)/токены(tokens). Занимается этим лексический анализатор или лексер(lexer). Он может определять классы токенов(token classes), вроде INT - целые чесла, ID - идентификаторы, ... Сами токены состоят из типа токена(который определяет лексическую структуру) и текста(который этому токену соответствует).

Далее эти токены передаются парсеру, который определяет структуру очерезного предложения и в результате генерирует синтаксическое дерево(syntax tree) или дерево парсинга(parse tree).

картинка 1

Листья дерева всегда определяют токены, промежуточные узлы определяют названия фраз, а самый верхний узел - это имя предложения. Эти деревья передаются дальше остальной части приложения, в которой будет происходить их обход и какие-то действия. 

Мы описываем структуры фразы с момощью набора правил, а это значит, что корням поддеревьев(subtree roots) будут соответствовать имена правил в грамматике.

Вообще, если нескольким приложениям необходимо распознавать тот же язык, то они могут переиспользовать тот же самый парсер. Это возможно, если мы в саму грамматику не поместили специфичные для приложения участки кода. ANTLR4 это умеет, но предпочтительно в грамматику ничего не встраивать.

Имея дерево, мы можем производить множество его обходом(passes, tree walks). Это полезно когда за один обход нельзя провести необходимый анализ.

--- 2.2 ---

ANTLR4 из грамматики генерирует парсер рекурсивного спуска(recursive-descent parser) - по сути, это просто набор рекурсивных методов(один метод - одно правило). Термин спуск говорит, что парсинг начинается с корня дерева и двигается по направлению к листьям. Начальный символ(???)(start symbol) - первый метод, который мы вызываем - становится корнем дерева. Данный тип парсинга является представляет нисходящий парсинг(top-down parsing), т.е. этот тип парсера является одним из видом нисходящего парсера(top-down parser).

Допустим, есть правило:
```
assign : ID '=' expr ';' ;
```
Для него ANTLR4 генерирует такой метод:
```
void assign() {
    match(ID);
    match('=');
    expr();
    match(';');
}
```
Что хорошо в таких парсерах, сам граф вызовов этих методов отражает внутреннюю структуру дерева(его узлы), а вызовы match() соответствуют листьям.

В правилах мы можем справа определять альтернативы(alternatives) - лишь одна из них будет выбрана парсером:
```
stat: assign
    | ifstat
    | whilestat
    ...
    ;
```
Мы получим следующее:
```
void stat() {
    switch( <следующий токен> ) {
        case ID     : assign(); break;
        case IF     : ifstat(); break;
        case WHILE  : whilestat(); break;
        ...
        default     : <исключение - нет подходящей альтернативы>
    }
}
```
В данном методы мы делаем предсказание(prediction) или решение о парсинге(??)(parsing decision), проверяя следующий токен(lookahead token) - токен, который парсер учитывает, но пока не потребляет. Иногда может потребоваться несколько таких токенов.

--- 2.3 ---

В языках программирования двусмысленная/неопределённаяа(anambiguous) грамматика не допустима, т.к. нам унжно точно определить смысл той или иной конструкции. Когда ANTLR4 видит двусмысленность, он выбирает первую альтернативу. Такие двусмысленности могут быть как в парсере, так и в лексере(здесь будет выбрано правило, указанное первым в грамматике).

Частый пример неопределённости между правилами для ключевых слов и идентификаторов:
```
BEGIN : 'begin' ;
ID    : [a-z]+ ;
```
В данном случае лексер может выбрать для слова 'begin' любое из правил, но выберет первое. Нужно иметь в виду, что лексер пытается провести сопоставление с самой длинной строкой для каждого токена.

Семантика(semantics) = смысл(meaning). 

--- 2.4 ---

Нам нужно выполнять подходящий код для кажной фразы или подфразы. Это можно делать при обходе дерева. 

Нужно понимать структуры данных и классы, которые ANTLR4 использует для распознания и построение/обхода дерева. Самые важные из них: CharStream, Lexer, Token, TokenStream, RuleNode, TerminalNode, Parser и ParseTree. TokenStream - соединяет лексер и парсер.

картинка 2 

Эти структуры стараются разделять как можно больше данных, чтобы снизить потребление памяти. Токены хранят начальный и конечный индексы символы в CharStream(потоке символов) вместо того, чтобы копировать подстроки. Пробельные символы обычно отбрасываются. 

Класс RuleNode и TerminalNode отражают корни поддеревьев(узлы) и листья соостветственно. У первого есть методы getChild() и getParent(), при этом они не привязаны к конкретной грамматике. Однако для каждого правила грамматики генерируются специфичный подкласс RuleNode для удобства, например: StatContext, AssignContext и ExprContext. 

Эти объекты являются контекстными объетами(context objects), потому что они хранят всё, что мы знаем об фразе - начальный и конечный токены фразы, а также имеют методы для доступа ко всем элементам фразы.

картинка 3

--- 2.5 ---

ANTLR4 предоставляет два механизма обхода дерева в библиотеке времени выполнения(runtime library): слушатели(listeners) и визиторы(visitors). По умолчанию генерируется интерфейс слушателя, который реагирует на события при обходе - просто вызываются колбэки(callbacks).

ANTLR4 предоставляет класс ParseTreeWalker, чтобы обходить дерево и триггерить колбэки. У нас есть ParseTreeListener интерфейс, реализации которого будут хранить специфичный для каждого правила грамматики код - методы для входа и выхода из правила. Например, при входе в узел assign вызывается метод enterAssign() и передаётся ему AssignContext объект. После обхода всех подузлов вызывается extiAssign().

картинка 4

Иногда мы сами хотим контролировать обход дерева, явно вызывая методы для посещения подузлов. Если передать опцию -visitor, то можно сгенерировать интерфес визитора с методами для каждого правила грамматики. При этом у каждого метода есть реализации по умолчанию, и нам нужно переопределять только те методы, в которых мы заинтересованы.

картинка 5

